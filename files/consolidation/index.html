<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="css/backpack.css">
    <link rel="stylesheet" href="css/github-light.css">
    <meta name="viewport" content="width=device-width">
    <title>Consolidation - Home</title>
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
      <div id="main">
  <h1>Consolidation of Haskell Programs</h1>
  <h2>Semantic Fusion of maps, filters and folds</h2>
  <div id="authors">
    <div class="author">
      <a class="name" href="http://www.aesadde.xyz" title="Alberto Sadde">Alberto Sadde</a><br>
      Department of Computer Science, University of Oxford
    </div>
  </div>
  <div id="info">
    <a class="link" title="paper (pdf)" href="content/paper.pdf">Paper (pdf)</a>
    <a class="link" title="hackage survey" href="survey.html">Hackage Survey</a>
    <a class="link" title="source code" href="source.html">Source Code</a>
  </div>

  <div id="abstract">
    <p>
    Program consolidation is a recent, correct-by-construction program optimization
    calculus that exploits semantic relations between terms in multiple programs to
    obtain a <i>consolidated</i> program that is sound optimization of the
    sequential execution of the original programs.  Inspired by its success in the
    imperative setting, where the focus is on domain-specific languages without
    side effects, in this paper we explore its applicability in the setting of a
    functional language.  Motivated by the latest developments in logical
    verification for Haskell such as refinement types, we present
    our <i>consolidation theory</i> as a set of inference rules annotated with
    semantic information.  Furthermore, following the renewed interest in
    improvement theory, an operational theory that aims to bring rigour to
    efficiency improvement proofs, we present a cost-annotated operational
    semantics for a call-by-value lambda calculus that we use to formally show that
    the consolidation rules, when applicable, yield efficiency improvements.  We
    also present the results of a survey of the Haskell ecosystem and a series of
    benchmarks that show that exploiting semantic dependencies between inputs is a
    viable direction to optimise performance and memory consumption of a broad
    range of functional programs.
    </p>
  </div>
</div>

    <!-- <div id="footer"> -->
    <!--   Site proudly generated by -->
    <!--   <a href="http://jaspervdj.be/hakyll">Hakyll</a> -->
    <!-- </div> -->
  </body>
</html>
